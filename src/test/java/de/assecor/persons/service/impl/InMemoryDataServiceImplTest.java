package de.assecor.persons.service.impl;

import de.assecor.persons.exception.InvalidColorException;
import de.assecor.persons.exception.PersonNotFoundException;
import de.assecor.persons.model.Color;
import de.assecor.persons.model.dto.PersonDto;
import de.assecor.persons.exception.DataLoadException;
import de.assecor.persons.service.initialdata.InitialDataProvider;
import de.assecor.persons.service.initialdata.ListInitialDataProvider;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("InMemoryDataService Tests")
class InMemoryDataServiceImplTest {

  private InMemoryDataServiceImpl dataService;

  @BeforeEach
  void setUp() {
    dataService = new InMemoryDataServiceImpl(null);
  }

  @Nested
  @DisplayName("Create Person Tests")
  class CreatePersonTests {

    @Test
    @DisplayName("Should create person with auto-generated ID")
    void shouldCreatePersonWithAutoGeneratedId() {
      PersonDto personToCreate = new PersonDto(0, "John", "Doe", "12345", "TestCity", 1);

      PersonDto createdPerson = dataService.createPerson(personToCreate);

      assertNotNull(createdPerson);
      assertEquals(1, createdPerson.id());
      assertEquals("John", createdPerson.firstName());
      assertEquals("Doe", createdPerson.lastName());
      assertEquals("12345", createdPerson.zipCode());
      assertEquals("TestCity", createdPerson.city());
      assertEquals(1, createdPerson.favoriteColor());
    }

    @Test
    @DisplayName("Should increment ID for multiple persons")
    void shouldIncrementIdForMultiplePersons() {
      PersonDto person1 = new PersonDto(0, "John", "Doe", "12345", "TestCity", 1);
      PersonDto person2 = new PersonDto(0, "Jane", "Smith", "67890", "AnotherCity", 2);

      PersonDto created1 = dataService.createPerson(person1);
      PersonDto created2 = dataService.createPerson(person2);

      assertEquals(1, created1.id());
      assertEquals(2, created2.id());
    }

    @Test
    @DisplayName("Should throw exception when creating null person")
    void shouldThrowExceptionWhenCreatingNullPerson() {
      assertThrows(IllegalArgumentException.class, () -> dataService.createPerson(null));
    }
  }

  @Nested
  @DisplayName("Get Person Tests")
  class GetPersonTests {

    @Test
    @DisplayName("Should get person by ID")
    void shouldGetPersonById() {
      PersonDto person = new PersonDto(0, "John", "Doe", "12345", "TestCity", 1);
      PersonDto created = dataService.createPerson(person);

      PersonDto retrieved = dataService.getPersonById(created.id());

      assertNotNull(retrieved);
      assertEquals(created.id(), retrieved.id());
      assertEquals("John", retrieved.firstName());
    }

    @Test
    @DisplayName("Should throw exception when person not found")
    void shouldThrowExceptionWhenPersonNotFound() {
      assertThrows(PersonNotFoundException.class, () -> dataService.getPersonById(999));
    }

    @Test
    @DisplayName("Should get all persons")
    void shouldGetAllPersons() {
      dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));
      dataService.createPerson(new PersonDto(0, "Jane", "Smith", "67890", "City2", 2));

      List<PersonDto> allPersons = dataService.getAllPersons();

      assertEquals(2, allPersons.size());
    }

    @Test
    @DisplayName("Should return empty list when no persons exist")
    void shouldReturnEmptyListWhenNoPersonsExist() {
      List<PersonDto> allPersons = dataService.getAllPersons();

      assertNotNull(allPersons);
      assertTrue(allPersons.isEmpty());
    }

    @Test
    @DisplayName("Should return unmodifiable list")
    void shouldReturnUnmodifiableList() {
      dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));

      List<PersonDto> allPersons = dataService.getAllPersons();

      assertThrows(
          UnsupportedOperationException.class,
          () -> allPersons.add(new PersonDto(99, "Test", "Test", "11111", "Test", 1)));
    }
  }

  @Nested
  @DisplayName("Update Person Tests")
  class UpdatePersonTests {

    @Test
    @DisplayName("Should update existing person - O(n) complexity")
    void shouldUpdateExistingPerson() {
      PersonDto original =
          dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));

      PersonDto updated =
          dataService.updatePerson(
              original.id(), new PersonDto(0, "Jane", "Smith", "67890", "City2", 2));

      assertEquals(original.id(), updated.id());
      assertEquals("Jane", updated.firstName());
      assertEquals("Smith", updated.lastName());
      assertEquals("67890", updated.zipCode());
      assertEquals("City2", updated.city());
      assertEquals(2, updated.favoriteColor());
    }

    @Test
    @DisplayName("Should throw exception when updating non-existent person")
    void shouldThrowExceptionWhenUpdatingNonExistentPerson() {
      PersonDto person = new PersonDto(0, "John", "Doe", "12345", "City1", 1);

      assertThrows(PersonNotFoundException.class, () -> dataService.updatePerson(999, person));
    }

    @Test
    @DisplayName("Should throw exception when updating with null person")
    void shouldThrowExceptionWhenUpdatingWithNullPerson() {
      PersonDto original =
          dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));

      assertThrows(
          IllegalArgumentException.class, () -> dataService.updatePerson(original.id(), null));
    }

    @Test
    @DisplayName("Should verify O(n) performance by updating person in middle of list")
    void shouldVerifyOnPerformanceByUpdatingPersonInMiddleOfList() {
      dataService.createPerson(new PersonDto(0, "Person1", "Last1", "11111", "City1", 1));
      PersonDto middle =
          dataService.createPerson(new PersonDto(0, "Person2", "Last2", "22222", "City2", 2));
      dataService.createPerson(new PersonDto(0, "Person3", "Last3", "33333", "City3", 3));

      PersonDto updated =
          dataService.updatePerson(
              middle.id(), new PersonDto(0, "Updated", "Person", "99999", "NewCity", 4));

      assertEquals(middle.id(), updated.id());
      assertEquals("Updated", updated.firstName());
      assertEquals(3, dataService.getAllPersons().size());
    }
  }

  @Nested
  @DisplayName("Delete Person Tests")
  class DeletePersonTests {

    @Test
    @DisplayName("Should delete existing person")
    void shouldDeleteExistingPerson() {
      PersonDto person =
          dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));

      dataService.deletePerson(person.id());

      assertEquals(0, dataService.getAllPersons().size());
      assertThrows(PersonNotFoundException.class, () -> dataService.getPersonById(person.id()));
    }

    @Test
    @DisplayName("Should throw exception when deleting non-existent person")
    void shouldThrowExceptionWhenDeletingNonExistentPerson() {
      assertThrows(PersonNotFoundException.class, () -> dataService.deletePerson(999));
    }

    @Test
    @DisplayName("Should only delete specified person")
    void shouldOnlyDeleteSpecifiedPerson() {
      PersonDto person1 =
          dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));
      PersonDto person2 =
          dataService.createPerson(new PersonDto(0, "Jane", "Smith", "67890", "City2", 2));

      dataService.deletePerson(person1.id());

      assertEquals(1, dataService.getAllPersons().size());
      assertEquals(person2.id(), dataService.getAllPersons().getFirst().id());
    }
  }

  @Nested
  @DisplayName("Get Persons By Color Tests")
  class GetPersonsByColorTests {

    @Test
    @DisplayName("Should get persons by color")
    void shouldGetPersonsByColor() {
      dataService.createPerson(
          new PersonDto(0, "John", "Doe", "12345", "City1", Color.BLUE.getId()));
      dataService.createPerson(
          new PersonDto(0, "Jane", "Smith", "67890", "City2", Color.RED.getId()));
      dataService.createPerson(
          new PersonDto(0, "Bob", "Johnson", "11111", "City3", Color.BLUE.getId()));

      List<PersonDto> bluePersons = dataService.getPersonsByColor(Color.BLUE);

      assertEquals(2, bluePersons.size());
      assertTrue(bluePersons.stream().allMatch(p -> p.favoriteColor() == Color.BLUE.getId()));
    }

    @Test
    @DisplayName("Should return empty list when no persons have specified color")
    void shouldReturnEmptyListWhenNoPersonsHaveSpecifiedColor() {
      dataService.createPerson(
          new PersonDto(0, "John", "Doe", "12345", "City1", Color.BLUE.getId()));

      List<PersonDto> redPersons = dataService.getPersonsByColor(Color.RED);

      assertNotNull(redPersons);
      assertTrue(redPersons.isEmpty());
    }

    @Test
    @DisplayName("Should throw exception when color is null")
    void shouldThrowExceptionWhenColorIsNull() {
      assertThrows(InvalidColorException.class, () -> dataService.getPersonsByColor(null));
    }
  }

  @Nested
  @DisplayName("Data Initialization Tests")
  class DataInitializationTests {

    @Test
    @DisplayName("Should initialize with list data source loader")
    void shouldInitializeWithListDataSourceLoader() {
      List<PersonDto> initialData =
          Arrays.asList(
              new PersonDto(0, "John", "Doe", "12345", "City1", 1),
              new PersonDto(0, "Jane", "Smith", "67890", "City2", 2));

      ListInitialDataProvider loader = new ListInitialDataProvider(initialData);
      InMemoryDataServiceImpl serviceWithLoader = new InMemoryDataServiceImpl(loader);
      serviceWithLoader.init();

      assertEquals(2, serviceWithLoader.getAllPersons().size());
    }

    @Test
    @DisplayName("Should handle empty list in data source loader")
    void shouldHandleEmptyListInDataSourceLoader() {
      ListInitialDataProvider loader = new ListInitialDataProvider(new ArrayList<>());
      InMemoryDataServiceImpl serviceWithLoader = new InMemoryDataServiceImpl(loader);
      serviceWithLoader.init();

      assertEquals(0, serviceWithLoader.getAllPersons().size());
    }

    @Test
    @DisplayName("Should handle null list in data source loader")
    void shouldHandleNullListInDataSourceLoader() {
      ListInitialDataProvider loader = new ListInitialDataProvider(null);
      InMemoryDataServiceImpl serviceWithLoader = new InMemoryDataServiceImpl(loader);
      serviceWithLoader.init();

      assertEquals(0, serviceWithLoader.getAllPersons().size());
    }

    @Test
    @DisplayName("Should initialize with CSV data source loader")
    void shouldInitializeWithCsvDataSourceLoader() throws DataLoadException {
      InitialDataProvider mockLoader =
          new InitialDataProvider() {
            @Override
            public List<PersonDto> loadData() {
              return List.of(new PersonDto(0, "Loaded", "Person", "12345", "LoadedCity", 1));
            }

            @Override
            public boolean isAvailable() {
              return true;
            }
          };

      InMemoryDataServiceImpl serviceWithLoader = new InMemoryDataServiceImpl(mockLoader);
      serviceWithLoader.init();

      assertEquals(1, serviceWithLoader.getAllPersons().size());
      assertEquals("Loaded", serviceWithLoader.getAllPersons().getFirst().firstName());
    }

    @Test
    @DisplayName("Should handle data source loader errors gracefully")
    void shouldHandleDataSourceLoaderErrorsGracefully() throws DataLoadException {
      InitialDataProvider failingLoader =
          new InitialDataProvider() {
            @Override
            public List<PersonDto> loadData() throws DataLoadException {
              throw new DataLoadException("Test error");
            }

            @Override
            public boolean isAvailable() {
              return true;
            }
          };

      InMemoryDataServiceImpl serviceWithLoader = new InMemoryDataServiceImpl(failingLoader);
      serviceWithLoader.init();

      assertEquals(0, serviceWithLoader.getAllPersons().size());
    }
  }

  @Nested
  @DisplayName("Utility Methods Tests")
  class UtilityMethodsTests {

    @Test
    @DisplayName("Should return correct size")
    void shouldReturnCorrectSize() {
      assertEquals(0, dataService.size());

      dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));
      assertEquals(1, dataService.size());

      dataService.createPerson(new PersonDto(0, "Jane", "Smith", "67890", "City2", 2));
      assertEquals(2, dataService.size());
    }

    @Test
    @DisplayName("Should clear all data")
    void shouldClearAllData() {
      dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));
      dataService.createPerson(new PersonDto(0, "Jane", "Smith", "67890", "City2", 2));

      dataService.clear();

      assertEquals(0, dataService.size());
      assertTrue(dataService.getAllPersons().isEmpty());
    }

    @Test
    @DisplayName("Should reset ID counter when clearing")
    void shouldResetIdCounterWhenClearing() {
      dataService.createPerson(new PersonDto(0, "John", "Doe", "12345", "City1", 1));
      dataService.createPerson(new PersonDto(0, "Jane", "Smith", "67890", "City2", 2));

      dataService.clear();

      PersonDto newPerson =
          dataService.createPerson(new PersonDto(0, "New", "Person", "11111", "City", 1));
      assertEquals(1, newPerson.id());
    }
  }

  @Nested
  @DisplayName("Thread Safety Tests")
  class ThreadSafetyTests {

    @Test
    @DisplayName("Should handle concurrent reads and writes")
    void shouldHandleConcurrentReadsAndWrites() throws InterruptedException {
      for (int i = 0; i < 10; i++) {
        dataService.createPerson(
            new PersonDto(0, "Person" + i, "Last" + i, Integer.toString(10000 + i), "City" + i, 1));
      }

      Thread[] threads = new Thread[5];
      for (int i = 0; i < threads.length; i++) {
        threads[i] =
            new Thread(
                () -> {
                  for (int j = 0; j < 10; j++) {
                    dataService.createPerson(
                        new PersonDto(0, "ThreadPerson", "ThreadLast", "99999", "ThreadCity", 1));
                    dataService.getAllPersons();
                  }
                });
        threads[i].start();
      }

      for (Thread thread : threads) {
        thread.join();
      }

      assertEquals(60, dataService.getAllPersons().size());
    }
  }
}
